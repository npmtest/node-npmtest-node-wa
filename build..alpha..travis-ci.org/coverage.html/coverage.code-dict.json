{"/home/travis/build/npmtest/node-npmtest-node-wa/test.js":"/* istanbul instrument in package npmtest_node_wa */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-wa/lib.npmtest_node_wa.js":"/* istanbul instrument in package npmtest_node_wa */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_node_wa = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_node_wa = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-node-wa/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-node-wa && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_node_wa */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_node_wa\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_node_wa.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_node_wa.rollup.js'] =\n            local.assetsDict['/assets.npmtest_node_wa.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_node_wa.__dirname + '/lib.npmtest_node_wa.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-node-wa/node_modules/node-wa/index.js":"var net = require('net');\nvar base64 = require('./libs/base64');\nvar crypto = require('crypto');\nvar fs = require('fs');\nvar uuid = require('./libs/uuid');\n\nfunction md5(x) {\n    return crypto.createHash('md5').update(x).digest(\"hex\");\n}\nfunction bytesToHex(bytes) {\n    /*var ret = Buffer(bytes.length * 2); // hmmm\n    var i = 0;\n    for(var c = 0; c < bytes.length; c++) {\n        var ub = bytes[c];\n        if(ub < 0) {\n            ub += 256;\n        }\n        ret[i] = forDigit(ub >> 4);\n        i += 1;\n        ret[i] = forDigit(ub % 16);\n        i += 1;\n    }\n    return ret;*/\n    return bytes.toString(\"hex\");\n}\n\nfunction forDigit(b) {\n    if(b < 10) {\n        return (48 + b);\n    } else {\n        return (97 + b - 10);\n    }\n}\n\nfunction hex2str(hex) {\n    var str = '';\n    for(var i = 0; i < hex.length; i += 2)\n        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));\n    return str;\n}\n\nfunction _hex(in_int)\n{\n    console.log(\"_hex\", in_int, in_int.toString(16));\n    return in_int.toString(16);\n}\n\nfunction splitBuffer(buf, char) {\n    var arr = [], p = 0;\n    for(var i = 0; i <= buf.length; i++) {\n        if(buf[i] !== char) continue;\n        if(i === 0) {\n            p = 0;\n            i = 0;\n        }\n        arr.push(buf.slice(p, i));\n        p = i + 1;\n    }\n    arr.push(buf.slice(p));\n    return arr;\n}\n\nfunction array_shift (inputArr) {\n    // Pops an element off the beginning of the array  \n    // \n    // version: 1109.2015\n    // discuss at: http://phpjs.org/functions/array_shift\n    // +   original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n    // +   improved by: Martijn Wieringa\n    // %        note 1: Currently does not handle objects\n    // *     example 1: array_shift(['Kevin', 'van', 'Zonneveld']);\n    // *     returns 1: 'Kevin'\n    var props = false,\n        shift = undefined,\n        pr = '',\n        allDigits = /^\\d$/,\n        int_ct = -1,\n        _checkToUpIndices = function (arr, ct, key) {\n            // Deal with situation, e.g., if encounter index 4 and try to set it to 0, but 0 exists later in loop (need to\n            // increment all subsequent (skipping current key, since we need its value below) until find unused)\n            if (arr[ct] !== undefined) {\n                var tmp = ct;\n                ct += 1;\n                if (ct === key) {\n                    ct += 1;\n                }\n                ct = _checkToUpIndices(arr, ct, key);\n                arr[ct] = arr[tmp];\n                delete arr[tmp];\n            }\n            return ct;\n        };\n \n \n    if (inputArr.length === 0) {\n        return null;\n    }\n    if (inputArr.length > 0) {\n        return inputArr.shift();\n    }\n}\n\nvar EventEmitter = require('events').EventEmitter;\n\nif(process.version == \"v0.2.3\") {\n    util = {};\n    util.inherits = require('sys').inherits;\n} else {\n    util = require('util');\n}\n\nvar nodes = require('./libs/whatsapp');\nvar ProtocolTreeNode = nodes.ProtocolTreeNode;\nvar BinTreeNodeWriter = nodes.BinTreeNodeWriter;\nvar BinTreeNodeReader = nodes.BinTreeNodeReader;\n\nvar waApi = function(username, password, opt) {\n    var self = this;\n    \n    self.debug = opt ? opt.debug : false;\n    self.iqId = 0;\n    console.log(\"*** constructing waApi for \" + username + \": \" + password);\n    self.loginInfo = {\n        username: username,\n        password: password,\n        resource: \"iPhone-2.8.2-5222\", // Symbian-2.6.61-443\n        domain: \"s.whatsapp.net\",\n        displayName: opt.displayName || \"Whazaa!\"\n    };\n    self.socket = net.createConnection(5222, 'bin-short.whatsapp.net');\n    self.writer = new BinTreeNodeWriter(self.socket, dictionary, { debug: self.debug });\n    self.reader = new BinTreeNodeReader(self.socket, dictionary, { debug: self.debug });\n    \n    self.socket.addListener('connect', function socketConnected() {\n        console.log(\"*** socket connected\");\n        self.reader.streamStart();\n        self.writer.streamStart(self.loginInfo.domain, self.loginInfo.resource);\n        \n        var features = [\n            new ProtocolTreeNode(\"receipt_acks\"),\n            // TODO: enabling this throws a stream:error at the moment.. bad dictionary?\n            //new ProtocolTreeNode(\"w:profile:picture\", { type: \"all\" }),\n            new ProtocolTreeNode(\"status\")\n        ];\n        var toWrite = new ProtocolTreeNode(\"stream:features\", { }, features);\n        \n        console.log(\"writing features:\" + toWrite);\n        self.writer.write(toWrite);\n        \n        var node = new ProtocolTreeNode(\"auth\", { \"mechanism\":\"DIGEST-MD5-1\",\"xmlns\":\"urn:ietf:params:xml:ns:xmpp-sasl\" });\n        console.log(\"sending auth:\" + node);\n        self.writer.write(node);\n    }.bind(self));\n    \n    self.socket.addListener('close', function socketClosed(x) {\n        console.log(\"***************** SOCKET CLOSED ******************* \" + JSON.stringify(x));\n        //if(!this.noReconnect)\n        //    this.socket.connect(5222, 'bin-short.whatsapp.net');\n        self.emit('close');\n    }.bind(self));\n    \n    self.socket.addListener('error', function socketError(err) {\n        console.log(\"***************** SOCKET ERROR ********************\" + JSON.stringify(err));\n        // {\"message\":\"ECONNREFUSED, Could not contact DNS servers\",\"stack\":\"Error: ECONNREFUSED, Could not contact DNS servers\\n    at IOWatcher.callback (dns.js:74:15)\",\"errno\":11,\"code\":\"ECONNREFUSED\"}\n        self.noReconnect = true;\n    }.bind(self));\n    \n    self.reader.addListener('stanza', function handleStanza(node) {\n        if(node.tag == \"failure\" && node.getAttributeValue(\"xmlns\") == \"urn:ietf:params:xml:ns:xmpp-sasl\" && node.getChild(\"not-authorized\"))\n        {\n            console.log(\"**** ACCESS NOT AUTHORIZED\");\n            self.emit('notAuthorized');\n            self.noReconnect = true;\n            self.socket.end();\n        }\n        if(node.tag == \"error\" && node.getAttributeValue(\"code\") == \"404\" && node.getAttributeValue(\"type\") == \"cancel\")\n        {\n            //<error code=\"404\" type=\"cancel\"> are children of <iq type=\"error\", and I think we can safely ignore them as long as we emit the error.. ??\n            return;\n        }\n        if(node.tag == \"item-not-found\" && node.getAttributeValue(\"xmlns\") == \"urn:ietf:params:xml:ns:xmpp-stanzas\") {\n            // same as above\n            return;\n        }\n        console.log(\"received stanza: \" + node);\n    }.bind(self));\n    \n    self.reader.addListener('challenge', function handleChallenge(node) {\n        console.log(\"**** Decoding Challenge\");\n        var challenge = base64.base64.decode(node.data.toString(\"binary\"));\n        console.log(\"*** Challenge = \" + challenge);\n                \n        var i = challenge.indexOf('nonce=\"');\n        i += 'nonce=\"'.length;\n        var j = challenge.indexOf('\"', i);\n        var nonce = challenge.substring(i, j);\n        console.log(\"nonce=\" + nonce);\n        var cnonce = uuid.v4();\n        console.log(\"cnonce=\" + cnonce);\n        var nc = \"00000001\";\n        console.log(\"nc=\" + nc);\n        var digest_uri = \"xmpp/\" + self.loginInfo.domain;\n        console.log(\"digest_uri=\" + digest_uri);\n        var qop=\"auth\";\n        var realm = self.loginInfo.domain;\n\n        var a1 = self.loginInfo.username + \":\" + self.loginInfo.domain + \":\" + self.loginInfo.password;\n        a1 = pack('H32', md5(a1)) + \":\" + nonce + \":\" + cnonce;\n        var a2 = \"AUTHENTICATE:\" + \"xmpp/\" + self.loginInfo.domain;\n        var password = md5(a1) + \":\" + nonce + \":\" + nc + \":\" + cnonce + \":\" + qop + \":\" + md5(a2);\n        console.log(\"password prior to encoding:\" + password);\n        password = md5(password);\n        console.log(\"password post encoding: \" + password);\n        var bigger_response = 'username=\"' + self.loginInfo.username + '\",'\n                    + 'realm=\"' + realm + '\",'\n                    + 'nonce=\"' + nonce + '\",'\n                    + 'cnonce=\"' + cnonce + '\",'\n                    + 'nc=' + nc + ','\n                    + 'qop=' + qop + ','\n                    + 'digest-uri=\"' + digest_uri + '\",'\n                    + 'response=' + password + ','\n                    + 'charset=utf-8';\n        console.log(\"response=\" + bigger_response);\n        \n        var node = new ProtocolTreeNode(\"response\", { \"xmlns\": \"urn:ietf:params:xml:ns:xmpp-sasl\" }, undefined, base64.base64.encode(bigger_response));\n        console.log(\"Responding with node: \" + node);\n        self.writer.write(node);\n        \n        self.sendClientConfig('', '', false, '');\n        \n    }.bind(self));\n    \n    self.reader.addListener('loggedin', function loggedIn(data) {\n        console.log(\"*** Successfully logged in.  Account status: \" + data.getAttributeValue(\"status\"));\n        console.log(\"*** Creation Timestamp: \" + data.getAttributeValue(\"creation\"));\n        console.log(\"*** Expiration Timestamp: \" + data.getAttributeValue(\"expiration\"));\n        self.sendAvailable();\n        self.sendAvailableForChat();\n        self.emit('loggedin');\n    }.bind(self));\n    \n    self.reader.addListener('iq', function receivedIq(data) {\n        //console.log(\"received iq: \" + data);\n        var iqType = data.getAttributeValue(\"type\");\n        var idx = data.getAttributeValue(\"id\");\n        var jid = data.getAttributeValue(\"from\");\n        \n        if(!iqType) {\n            throw(\"received iq with no type, data=\" + data);\n        }\n        switch(iqType) {\n            case \"get\":\n                var childNode = data.getChild(0);\n                if(childNode.tag === \"ping\") {\n                    self.handlePing(idx);\n                }\n                break;\n            case \"error\":\n/*\n<iq from=\"+9597896522@s.whatsapp.net\" id=\"last_14\" type=\"error\">\n    <error code=\"404\" type=\"cancel\">\n    <item-not-found xmlns=\"urn:ietf:params:xml:ns:xmpp-stanzas\">\n    </item-not-found>\n    </error>\n</iq>\n*/              self.emit('iqerror', data);\n                break;\n            case \"result\":\n                var queryNode = data.getChild(\"query\");\n                if(queryNode && queryNode.getAttributeValue(\"xmlns\") === \"jabber:iq:last\") {\n                    self.emit('iqquerylast', { from: jid, seconds: queryNode.getAttributeValue(\"seconds\") });\n                    break;\n                }\n                // intentional fall thru for now\n                //break;\n            case \"set\":\n                // intentional fall thru for now\n                //break;\n            default:\n                console.log(\"received iq type: \" +iqType + \": \" + data);\n                break;\n        }\n    }.bind(self));\n    \n    self.reader.addListener('presence', function receivedPresence(data) {\n        console.log(\"received presence: \" + data);\n        self.emit('presence', { from: data.getAttributeValue(\"from\"), type: data.getAttributeValue(\"type\") });\n    }.bind(self));\n    \n    self.reader.addListener('streamError', function streamError(data) {\n        var childNode1 = data.getChild(\"text\");\n        if(!childNode1) {\n            console.log(\"**** Stream Error data: \" + data);\n        } else {\n            console.log(\"**** Stream Error: \" + childNode1.data);\n            if(childNode1.data == \"Replaced by new connection\") {\n                self.noReconnect = true; // make SURE it's true\n                self.emit('connectionReplaced');\n            }\n        }\n        console.log(\"******************************** STREAM ERROR NOT AUTO RECONNECTING ******************************\");\n        self.noReconnect = true;\n    }.bind(self));\n    \n    self.reader.addListener('message', function handleMessage(messageNode) {\n        console.log(\"**** Holy shit! A MESSAGE!\");\n        var emitMessage = true;\n        var msgId = messageNode.getAttributeValue(\"id\");\n        var attributeT = messageNode.getAttributeValue(\"t\");\n        var fromAttribute = messageNode.getAttributeValue(\"from\");\n        var author = messageNode.getAttributeValue(\"author\");\n        var typeAttribute = messageNode.getAttributeValue(\"type\");\n        var visibleName = \"\";\n        \n        console.log(\"*** Message is of type: \" + typeAttribute);\n        \n        if(typeAttribute === \"error\") {\n            console.log(\"*** My God, it's full of Errors.\");\n            console.log(messageNode);\n        } else if(typeAttribute == \"subject\") {\n            var receiptRequested = false;\n            var requestNodes = messageNode.getAllChildren(\"request\");\n            for(var requestNode in requestNodes) {\n                if(requestNodes[requestNode].getAttributeValue(\"xmlns\") == \"urn:xmpp:receipts\") {\n                    receiptRequested = true;\n                    break;\n                }\n            }\n            var bodyNode = messageNode.getChild(\"body\");\n            var newSubject = bodyNode ? bodyNode.data : undefined;\n            console.log(\"*** Subject received: \" + newSubject);\n            if(receiptRequested) {\n                self.sendSubjectReceived(fromAttribute, msgId);\n            }\n        } else if(typeAttribute == \"notification\") {\n            // TODO: I don't see a \"notification\" type in here anywhere, what's it do?\n        } else if(typeAttribute == \"chat\") {\n            var duplicate = false;\n            var wantsReceipt = false;\n            var messageChildren = messageNode.children || [];\n            for(var childNode in messageChildren) {\n                switch(messageChildren[childNode].tag) {\n                    case \"media\":\n                        var media = messageNode.getChild(\"media\");\n                        if(media) {\n                            console.log(\"*** Hmm. It has some media attached.  What should I do?!?!?\");\n                            console.log(media);\n                            var mediatype = media.getAttributeValue(\"type\");\n                            var mediaurl = media.getAttributeValue(\"url\");\n                            var mediafile = media.getAttributeValue(\"file\");\n                            var mediasize = media.getAttributeValue(\"size\");\n                            var medialength = media.getAttributeValue(\"seconds\");\n                            var medialatitude = media.getAttributeValue(\"latitude\");\n                            var medialongitude = media.getAttributeValue(\"longitude\");\n                            var medianame = media.getAttributeValue(\"name\");\n                            \n                            self.emit('media', { msgId: msgId, from: fromAttribute, type: mediatype,\n                                      url: mediaurl, file: mediafile, size: mediasize, length: medialength,\n                                      latitude: medialatitude, longitude: medialongitude, name: medianame });\n                            emitMessage = false;\n                        }\n                        break;\n                    case \"received\":\n                        console.log(\"*** \" + fromAttribute + \" received message \" + msgId);\n                        self.emit('msgReceived', { from: fromAttribute, id: msgId });\n                        self.sendDeliveredReceiptAck(fromAttribute, msgId);\n                        emitMessage = false;\n                        break;\n                    case \"composing\":\n                        console.log(\"*** \" + fromAttribute + \" is typing\");\n                        self.emit('composing', fromAttribute);\n                        emitMessage = false;\n                        break;\n                    case \"paused\":\n                        console.log(\"*** \" + fromAttribute + \" stopped typing\");\n                        self.emit('paused', fromAttribute);\n                        emitMessage = false;\n                        break;\n                    case \"body\":\n                        if(msgId) {\n                            var msgdata = messageChildren[childNode].data;\n                            // TODO: apparently we should check to see if this is a duplicate message using some kind of key based on fromAttribute and msgId\n                            // see waxmpp.py:556 for some of the sordid details\n                            console.log(\"*** \" + fromAttribute + \" says: \" + msgdata);\n                        }\n                        self.emit('message', messageNode);\n                        emitMessage = false;\n                        break;\n                    case \"request\":\n                        console.log(\"*** \" + fromAttribute + \" requests return receipt\");\n                        self.sendMessageReceived(fromAttribute, msgId);\n                        emitMessage = false;\n                        break;\n                    case \"notify\": \n                        console.log(\"*** \" + fromAttribute + \" sets notify_name=\" + messageChildren[childNode].getAttributeValue(\"name\"));\n                        visibleName = messageChildren[childNode].getAttributeValue(\"name\");\n                        break;\n                    case \"server\":\n                        console.log(\"*** Server says it has accepted message \" + msgId);\n                        self.emit('serverAccept', { from: fromAttribute, id: msgId });\n                        emitMessage = false;\n                        break;\n                    case \"x\": // why did someone called a stanza name \"x\"? what does that even -mean-?\n                        var xmlns = messageChildren[childNode].getAttributeValue(\"xmlns\");\n                        if(xmlns === \"jabber:x:event\" && msgId) {\n                            console.log(\"*** Message \" + msgId + \" sent to \" + fromAttribute);\n                        } else if(xmlns === \"jabber:x:delay\") {\n                            // uh.. what do we do here?\n                        }\n                        emitMessage = false;\n                        break;\n                    case \"delay\":\n                        break;\n                    default:\n                        if(!msgId || ! (messageChildren[childNode].tag == \"received\"))\n                        {\n                            break;\n                        }\n                        // TODO: I think we're supposed to handle sending return receipts here, as per waxmpp.py:600 or so\n                        console.log(\"*** I don't know what to do. Message Data=\" + messageChildren[childNode]);\n                        break;\n                }\n            }\n        }\n        //console.log(messageNode);\n        if(emitMessage) {\n            console.log(\"emitting message back to service\");\n            self.emit('message', messageNode);\n        }\n    }.bind(self));\n}\n\nutil.inherits(waApi, EventEmitter);\n\nwaApi.prototype.handlePing = function(idx) {\n    var iqNode = new ProtocolTreeNode(\"iq\", { \"type\": \"result\", \"to\": this.loginInfo.domain, \"id\": idx });\n    console.log(\"received ping \" + idx + \", sending Pong \" + iqNode);\n    this.writer.write(iqNode);\n}\n\n// TODO: use sendTyping\nwaApi.prototype.sendTyping = function(jid) {\n    console.log(\"*** Typing\");\n    var composing = new ProtocolTreeNode(\"composing\", { \"xmlns\": \"http://jabber.org/protocol/chatstates\" });\n    var message = new ProtocolTreeNode(\"message\", { \"to\": jid, \"type\": \"chat\" }, [ composing ]);\n    this.writer.write(message);\n}\n\n// TODO: use sendPaused\nwaApi.prototype.sendPaused = function(jid) {\n    console.log(\"*** Paused\");\n    var composing = new ProtocolTreeNode(\"paused\", { \"xmlns\": \"http://jabber.org/protocol/chatstates\" });\n    var message = new ProtocolTreeNode(\"message\", { \"to\": jid, \"type\": \"chat\" }, [ composing ]);\n    this.writer.write(message);\n}\n\nwaApi.prototype.getSubjectMessage = function(to, msgId, child) {\n    var messageNode = new ProtocolTreeNode(\"message\", { \"to\": to, \"type\": \"subject\", \"id\": msgId }, [ child ]);\n    return messageNode;\n}\n\nwaApi.prototype.sendSubjectReceived = function(to, msgId) {\n    var receivedNode = new ProtocolTreeNode(\"received\", { \"xmlns\": \"urn:xmpp:receipts\" });\n    var messageNode = this.getSubjectMessage(to, msgId, receivedNode);\n    this.writer.write(messageNode);\n}\n\nwaApi.prototype.sendMessageReceived = function(to, msgid) {\n    var receivedNode = new ProtocolTreeNode(\"received\", { \"xmlns\": \"urn:xmpp:receipts\" });\n    var messageNode = new ProtocolTreeNode(\"message\", { \"to\": to, \"type\": \"chat\", \"id\": msgid }, [ receivedNode ]);\n    this.writer.write(messageNode);\n}\n\nwaApi.prototype.sendDeliveredReceiptAck = function(to, msgId) {\n    this.writer.write(this.getReceiptAck(to, msgId, \"delivered\"));\n}\n\n// TODO: use sendVisibileReceiptAck\nwaApi.prototype.sendVisibleReceiptAck = function(to, msgId) {\n    this.writer.write(this.getReceiptAck(to, msgId, \"visible\"));\n}\n\nwaApi.prototype.getReceiptAck = function(to, msgId, receiptType) {\n    var ackNode = new ProtocolTreeNode(\"ack\", { \"xmlns\": \"urn:xmpp:receipts\", \"type\": receiptType });\n    var messageNode = new ProtocolTreeNode(\"message\", { \"to\": to, \"type\": \"chat\", \"id\": msgId }, [ ackNode ]);\n    return messageNode;\n}\n\nwaApi.prototype.makeId = function(prefix) {\n    this.iqId++;\n    var idx = \"\";\n    //if(this.verbose) {\n        idx += prefix + this.iqId; \n    //} else {\n    //    idx = this.iqId.toString(16);\n    //}\n    return idx;\n}\n\n// TODO: use getLastOnline\nwaApi.prototype.getLastOnline = function(jid) {\n    this.sendSubscribe(jid);\n    var idx = this.makeId(\"last_\");\n    var query = new ProtocolTreeNode(\"query\", { \"xmlns\":\"jabber:iq:last\" });\n    var iqNode = new ProtocolTreeNode(\"iq\", { \"id\": idx, \"type\": \"get\", \"to\": jid }, [query]);\n    this.writer.write(iqNode);\n}\n\n// TODO: use sendIq?\nwaApi.prototype.sendIq = function() {\n    var node = new ProtocolTreeNode(\"iq\", { \"to\": \"g.us\", \"type\": \"get\", \"id\": Date.now() + \"-0\" }, undefined, 'expired');\n    this.writer.write(node);\n    node = new ProtocolTreeNode(\"iq\", { \"to\": \"s.whatsapp.net\", \"type\": \"set\", \"id\": Date.now() + \"-1\" }, undefined, 'expired');\n    this.writer.write(node);\n}\n\nwaApi.prototype.sendAvailableForChat = function() {\n    var showNode = new ProtocolTreeNode(\"show\", undefined, undefined, \"chat\");\n    var presenceNode = new ProtocolTreeNode(\"presence\", { \"name\": this.loginInfo.displayName || \"\" });\n    this.writer.write(presenceNode);\n}\n\nwaApi.prototype.sendAvailable = function() {\n    var presenceNode = new ProtocolTreeNode(\"presence\", { \"type\": \"available\" });\n    this.writer.write(presenceNode);\n}\n\n// This might work. I can't see any changes from Android, but other people are reporting that they see a status update.\nwaApi.prototype.sendStatusUpdate = function(status) {\n    this.sendMessageWithBody({ to: \"s.us\", content: status });    \n}\n\n// TODO: use sendUnavailable\nwaApi.prototype.sendUnavailable = function(status) {\n    var presenceNode = new ProtocolTreeNode(\"presence\", { \"type\": \"unavailable\" });\n    this.writer.write(presenceNode);\n}\n\n// TODO: use sendSubscribe\nwaApi.prototype.sendSubscribe = function(to) {\n    var presenceNode = new ProtocolTreeNode(\"presence\", { \"type\": \"subscribe\", \"to\": to });\n    this.writer.write(presenceNode);\n}\n\n// TODO: use sendClientConfig\nwaApi.prototype.sendClientConfig = function(sound, pushID, preview, platform) {\n    var idx = this.makeId(\"config_\");\n    var configNode = new ProtocolTreeNode(\"config\", { \"xmlns\": \"urn:xmpp:whatsapp:push\", \"sound\": sound, \"id\": pushID, \"preview\": preview ? \"1\" : \"0\", \"platform\": platform });\n    var iqNode = new ProtocolTreeNode(\"iq\", { \"id\": idx, \"type\": \"set\", \"to\": this.loginInfo.domain }, [ configNode ]);\n    this.writer.write(iqNode);\n}\n\nwaApi.prototype.getMessageNode = function(fmsg, child) {\n    var requestNode = undefined;\n    var serverNode = new ProtocolTreeNode(\"server\");\n    var xNode = new ProtocolTreeNode(\"x\", { \"xmlns\":\"jabber:x:event\" }, [ serverNode ]);\n    var childCount = (requestNode ? 1 : 0) + 2;\n    var messageChildren = [];\n    var i = 0;\n    if(requestNode) {\n        messageChildren[i] = requestNode;\n        i++;\n    }\n    messageChildren[i] = xNode;\n    i++;\n    messageChildren[i] = child;\n    i++;\n    //var key = fmsg.key; // eval(fmsg.key) ???\n    var key = { id: Math.round(Date.now() / 1000) + \"-1\" };\n    //var key = { id: \"123456789-3\" };\n    var messageNode = new ProtocolTreeNode(\"message\", { \"to\": fmsg.to, \"type\": \"chat\", \"id\": key.id }, messageChildren);\n    return messageNode;\n}\n\nwaApi.prototype.sendMessageWithBody = function(fmsg) {\n    var bodyNode = new ProtocolTreeNode(\"body\", undefined, undefined, fmsg.content);\n    this.writer.write(this.getMessageNode(fmsg, bodyNode));\n    this.msgId++;\n}\n\nwaApi.prototype.sendMessageWithMedia = function() {\n    \n}\n\nwaApi.prototype.sendGetStatus = function(jid) {\n    var num = jid.indexOf('@');\n    if(num > -1) {\n        jid = jid.substring(0, num) + \"@s.us\";\n    }\n    var v = this.makeId(\"\");\n    var actionnode = new ProtocolTreeNode(\"action\", { type: \"get\" });\n    var node = new ProtocolTreeNode(\"message\", { to: jid, type: \"action\", id: v }, [ actionnode ]);\n    this.writer.write(node);\n}\n\nwaApi.prototype.sendNotificationReceived = function(jid, id) {\n    var child = new ProtocolTreeNode(\"received\", { xmlns: \"urn:xmpp:receipts\" });\n    var node = new ProtocolTreeNode(\"message\", { to: jid, type: \"notification\", id: id }, [ child ]);\n    this.writer.write(node);\n}\n\nwaApi.prototype.sendPresenceSubscriptionRequest = function(to) {\n    var node = new ProtocolTreeNode(\"presence\", { type: \"subscribe\", to: to });\n    this.writer.write(node);\n}\n\nwaApi.prototype.sendRelayComplete = function(id, ms) {\n    var child = new ProtocolTreeNode(\"relay\", { elapsed: ms });\n    var node = new ProtocolTreeNode(\"iq\", { xmlns: \"w:p:r\", type: \"result\", to: \"s.whatsapp.net\", id: id }, [ child ]);\n    this.writer.write(node);\n}\n\nwaApi.prototype.sendActive = function() {\n    this.writer.write(new ProtocolTreeNode(\"presence\", { type: \"active\" }));\n}\n\nwaApi.prototype.sendInactive = function() {\n    this.writer.write(new ProtocolTreeNode(\"presence\", { type: \"inactive\" }));\n}\n\nwaApi.prototype.sendRelayTimeout = function(id) {\n    var child = new ProtocolTreeNode(\"remote-server-timeout\", { xmlns: \"urn:ietf:params:xml:ns:xmpp-stanzas\" });\n    var child2 = new ProtocolTreeNode(\"error\", { code: \"504\", type: \"wait\" }, [ child ] );\n    var node = new ProtocolTreeNode(\"iq\", { xmlns: \"w:p:r\", type: \"error\", to: \"s.whatsapp.net\", id: id }, [ child2 ]);\n    this.writer.write(node);\n}\n\nwaApi.prototype.sendUnsubscribeMe = function(jid) {\n    this.writer.write(new ProtocolTreeNode(\"presence\", { type: \"unsubscribe\", to: jid }));\n}\n\nwaApi.prototype.sendUnsubscribeHim = function(jid) {\n    this.writer.write(new ProtocolTreeNode(\"presence\", { type: \"unsubscribed\", to: jid }));\n}\n\nwaApi.prototype.sendDeleteFromRoster = function(jid) {\n    var v = this.makeId(\"roster_\");\n    var child = new ProtocolTreeNode(\"item\", { jid: jid, subscription: \"remove\" });\n    var child2 = new ProtocolTreeNode(\"query\", { xmlns: \"jabber:iq:roster\" }, [ child ]);\n    var node = new ProtocolTreeNode(\"iq\", { type: \"set\", id: v }, [ child2 ]);\n    this.writer.write(node);\n}\n\nwaApi.prototype.sendClose = function() {\n    this.writer.write(new ProtocolTreeNode(\"presence\", { type: \"unavailable\" }));\n    // TODO: implement this\n    // this.writer.streamEnd();\n}\n\nwaApi.prototype.sendGetPrivacyList = function() {\n    var text = this.makeId(\"privacylist_\");\n    var child = new ProtocolTreeNode(\"list\", { name: \"default\" });\n    var child2 = new ProtocolTreeNode(\"query\", { xmlns: \"jabber:iq:privacy\" }, [ child ]);\n    var node = new ProtocolTreeNode(\"iq\", { id: text, type: \"get\" }, [ child2 ]);\n    this.writer.write(node);\n}\n\nwaApi.prototype.sendSetPrivacyBlockedList = function(jidList) {\n    var listnodes = [];\n    for(var x = 0; x < jidList.length; x++) {\n        listnodes.push(new ProtocolTreeNode(\"item\", { type: \"jid\", value: jidList[x], action: \"deny\", order: x }));\n    }\n    var child = new ProtocolTreeNode(\"list\", { name: \"default\" }, listnodes);\n    var child2 = new ProtocolTreeNode(\"query\", { xmlns: \"jabber:iq:privacy\" }, [ child ]);\n    var node = new ProtocolTreeNode(\"iq\", { id: text, type: \"set\" }, [ child2 ]);\n    this.writer.write(node);\n}\n\n\n//var wa = new waApi(\"17079925233\", \"134529771563\");\n//var wa = new waApi(\"19519993267\", \"134529771563\");\nexports.waApi = waApi;\n\n/*\n var ProtocolTreeNode = require('./whatsapp.js').ProtocolTreeNode;\n\nvar treenodetest = new ProtocolTreeNode(\"html\", undefined,\n    [\n        new ProtocolTreeNode(\"head\", undefined,\n            [\n                new ProtocolTreeNode(\"title\", undefined, undefined, \"Test Title\"),\n                new ProtocolTreeNode(\"script\", { src: \"/home/script.js\" },\n                    [\n                        new ProtocolTreeNode(\"noscript\", undefined, undefined, \"No Script Text\")\n                    ]\n                ),\n            ]\n        ),\n        new ProtocolTreeNode(\"body\", undefined, undefined, \"Test Body\"),\n    ],\n    undefined, undefined);\n        \nconsole.log(\"treenodetest created:\\n\" + treenodetest);\n*/\n\nfunction pack(format) {\n    // http://kevin.vanzonneveld.net\n    // +   original by: Tim de Koning (http://www.kingsquare.nl)\n    // +      parts by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\n    // +   bugfixed by: Tim de Koning (http://www.kingsquare.nl)\n    // %        note 1: Float encoding by: Jonas Raoni Soares Silva\n    // %        note 2: Home: http://www.kingsquare.nl/blog/12-12-2009/13507444\n    // %        note 3: Feedback: phpjs-pack@kingsquare.nl\n    // %        note 4: 'machine dependent byte order and size' aren't\n    // %        note 4: applicable for JavaScript; pack works as on a 32bit,\n    // %        note 4: little endian machine\n    // *     example 1: pack('nvc*', 0x1234, 0x5678, 65, 66);\n    // *     returns 1: '4xVAB'\n    var formatPointer = 0,\n        argumentPointer = 1,\n        result = '',\n        argument = '',\n        i = 0,\n        r = [],\n        instruction, quantifier, word, precisionBits, exponentBits, extraNullCount;\n\n    // vars used by float encoding\n    var bias, minExp, maxExp, minUnnormExp, status, exp, len, bin, signal, n, intPart, floatPart, lastBit, rounded, j, k, tmpResult;\n\n    while (formatPointer < format.length) {\n        instruction = format[formatPointer];\n        quantifier = '';\n        formatPointer++;\n        while ((formatPointer < format.length) && (format[formatPointer].match(/[\\d\\*]/) !== null)) {\n            quantifier += format[formatPointer];\n            formatPointer++;\n        }\n        if (quantifier === '') {\n            quantifier = '1';\n        }\n\n        // Now pack variables: 'quantifier' times 'instruction'\n        switch (instruction) {\n        case 'a':\n            // NUL-padded string\n        case 'A':\n            // SPACE-padded string\n            if (typeof arguments[argumentPointer] === 'undefined') {\n                throw new Error('Warning:  pack() Type ' + instruction + ': not enough arguments');\n            } else {\n                argument = String(arguments[argumentPointer]);\n            }\n            if (quantifier === '*') {\n                quantifier = argument.length;\n            }\n            for (i = 0; i < quantifier; i++) {\n                if (typeof argument[i] === 'undefined') {\n                    if (instruction === 'a') {\n                        result += String.fromCharCode(0);\n                    } else {\n                        result += ' ';\n                    }\n                } else {\n                    result += argument[i];\n                }\n            }\n            argumentPointer++;\n            break;\n        case 'h':\n            // Hex string, low nibble first\n        case 'H':\n            // Hex string, high nibble first\n            if (typeof arguments[argumentPointer] === 'undefined') {\n                throw new Error('Warning: pack() Type ' + instruction + ': not enough arguments');\n            } else {\n                argument = arguments[argumentPointer];\n            }\n            if (quantifier === '*') {\n                quantifier = argument.length;\n            }\n            if (quantifier > argument.length) {\n                throw new Error('Warning: pack() Type ' + instruction + ': not enough characters in string');\n            }\n            for (i = 0; i < quantifier; i += 2) {\n                // Always get per 2 bytes...\n                word = argument[i];\n                if (((i + 1) >= quantifier) || typeof(argument[i + 1]) === 'undefined') {\n                    word += '0';\n                } else {\n                    word += argument[i + 1];\n                }\n                // The fastest way to reverse?\n                if (instruction === 'h') {\n                    word = word[1] + word[0];\n                }\n                result += String.fromCharCode(parseInt(word, 16));\n            }\n            argumentPointer++;\n            break;\n\n        case 'c':\n            // signed char\n        case 'C':\n            // unsigned char\n            // c and C is the same in pack\n            if (quantifier === '*') {\n                quantifier = arguments.length - argumentPointer;\n            }\n            if (quantifier > (arguments.length - argumentPointer)) {\n                throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments');\n            }\n\n            for (i = 0; i < quantifier; i++) {\n                result += String.fromCharCode(arguments[argumentPointer]);\n                argumentPointer++;\n            }\n            break;\n\n        case 's':\n            // signed short (always 16 bit, machine byte order)\n        case 'S':\n            // unsigned short (always 16 bit, machine byte order)\n        case 'v':\n            // s and S is the same in pack\n            if (quantifier === '*') {\n                quantifier = arguments.length - argumentPointer;\n            }\n            if (quantifier > (arguments.length - argumentPointer)) {\n                throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments');\n            }\n\n            for (i = 0; i < quantifier; i++) {\n                result += String.fromCharCode(arguments[argumentPointer] & 0xFF);\n                result += String.fromCharCode(arguments[argumentPointer] >> 8 & 0xFF);\n                argumentPointer++;\n            }\n            break;\n\n        case 'n':\n            // unsigned short (always 16 bit, big endian byte order)\n            if (quantifier === '*') {\n                quantifier = arguments.length - argumentPointer;\n            }\n            if (quantifier > (arguments.length - argumentPointer)) {\n                throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments');\n            }\n\n            for (i = 0; i < quantifier; i++) {\n                result += String.fromCharCode(arguments[argumentPointer] >> 8 & 0xFF);\n                result += String.fromCharCode(arguments[argumentPointer] & 0xFF);\n                argumentPointer++;\n            }\n            break;\n\n        case 'i':\n            // signed integer (machine dependent size and byte order)\n        case 'I':\n            // unsigned integer (machine dependent size and byte order)\n        case 'l':\n            // signed long (always 32 bit, machine byte order)\n        case 'L':\n            // unsigned long (always 32 bit, machine byte order)\n        case 'V':\n            // unsigned long (always 32 bit, little endian byte order)\n            if (quantifier === '*') {\n                quantifier = arguments.length - argumentPointer;\n            }\n            if (quantifier > (arguments.length - argumentPointer)) {\n                throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments');\n            }\n\n            for (i = 0; i < quantifier; i++) {\n                result += String.fromCharCode(arguments[argumentPointer] & 0xFF);\n                result += String.fromCharCode(arguments[argumentPointer] >> 8 & 0xFF);\n                result += String.fromCharCode(arguments[argumentPointer] >> 16 & 0xFF);\n                result += String.fromCharCode(arguments[argumentPointer] >> 24 & 0xFF);\n                argumentPointer++;\n            }\n\n            break;\n        case 'N':\n            // unsigned long (always 32 bit, big endian byte order)\n            if (quantifier === '*') {\n                quantifier = arguments.length - argumentPointer;\n            }\n            if (quantifier > (arguments.length - argumentPointer)) {\n                throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments');\n            }\n\n            for (i = 0; i < quantifier; i++) {\n                result += String.fromCharCode(arguments[argumentPointer] >> 24 & 0xFF);\n                result += String.fromCharCode(arguments[argumentPointer] >> 16 & 0xFF);\n                result += String.fromCharCode(arguments[argumentPointer] >> 8 & 0xFF);\n                result += String.fromCharCode(arguments[argumentPointer] & 0xFF);\n                argumentPointer++;\n            }\n            break;\n\n        case 'f':\n            // float (machine dependent size and representation)\n        case 'd':\n            // double (machine dependent size and representation)\n            // version based on IEEE754\n            precisionBits = 23;\n            exponentBits = 8;\n            if (instruction === 'd') {\n                precisionBits = 52;\n                exponentBits = 11;\n            }\n\n            if (quantifier === '*') {\n                quantifier = arguments.length - argumentPointer;\n            }\n            if (quantifier > (arguments.length - argumentPointer)) {\n                throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments');\n            }\n            for (i = 0; i < quantifier; i++) {\n                argument = arguments[argumentPointer];\n                bias = Math.pow(2, exponentBits - 1) - 1;\n                minExp = -bias + 1;\n                maxExp = bias;\n                minUnnormExp = minExp - precisionBits;\n                status = isNaN(n = parseFloat(argument)) || n === -Infinity || n === +Infinity ? n : 0;\n                exp = 0;\n                len = 2 * bias + 1 + precisionBits + 3;\n                bin = new Array(len);\n                signal = (n = status !== 0 ? 0 : n) < 0;\n                n = Math.abs(n);\n                intPart = Math.floor(n);\n                floatPart = n - intPart;\n\n                for (k = len; k;) {\n                    bin[--k] = 0;\n                }\n                for (k = bias + 2; intPart && k;) {\n                    bin[--k] = intPart % 2;\n                    intPart = Math.floor(intPart / 2);\n                }\n                for (k = bias + 1; floatPart > 0 && k; --floatPart) {\n                    (bin[++k] = ((floatPart *= 2) >= 1) - 0);\n                }\n                for (k = -1; ++k < len && !bin[k];) {}\n\n                if (bin[(lastBit = precisionBits - 1 + (k = (exp = bias + 1 - k) >= minExp && exp <= maxExp ? k + 1 : bias + 1 - (exp = minExp - 1))) + 1]) {\n                    if (!(rounded = bin[lastBit])) {\n                        for (j = lastBit + 2; !rounded && j < len; rounded = bin[j++]) {}\n                    }\n                    for (j = lastBit + 1; rounded && --j >= 0;\n                    (bin[j] = !bin[j] - 0) && (rounded = 0)) {}\n                }\n\n                for (k = k - 2 < 0 ? -1 : k - 3; ++k < len && !bin[k];) {}\n\n                if ((exp = bias + 1 - k) >= minExp && exp <= maxExp) {\n                    ++k;\n                } else {\n                    if (exp < minExp) {\n                        if (exp !== bias + 1 - len && exp < minUnnormExp) { /*\"encodeFloat::float underflow\" */\n                        }\n                        k = bias + 1 - (exp = minExp - 1);\n                    }\n                }\n\n                if (intPart || status !== 0) {\n                    exp = maxExp + 1;\n                    k = bias + 2;\n                    if (status === -Infinity) {\n                        signal = 1;\n                    } else if (isNaN(status)) {\n                        bin[k] = 1;\n                    }\n                }\n\n                n = Math.abs(exp + bias);\n                tmpResult = '';\n\n                for (j = exponentBits + 1; --j;) {\n                    tmpResult = (n % 2) + tmpResult;\n                    n = n >>= 1;\n                }\n\n                n = 0;\n                j = 0;\n                k = (tmpResult = (signal ? '1' : '0') + tmpResult + bin.slice(k, k + precisionBits).join('')).length;\n                r = [];\n\n                for (; k;) {\n                    n += (1 << j) * tmpResult.charAt(--k);\n                    if (j === 7) {\n                        r[r.length] = String.fromCharCode(n);\n                        n = 0;\n                    }\n                    j = (j + 1) % 8;\n                }\n\n                r[r.length] = n ? String.fromCharCode(n) : '';\n                result += r.join('');\n                argumentPointer++;\n            }\n            break;\n\n        case 'x':\n            // NUL byte\n            if (quantifier === '*') {\n                throw new Error('Warning: pack(): Type x: \\'*\\' ignored');\n            }\n            for (i = 0; i < quantifier; i++) {\n                result += String.fromCharCode(0);\n            }\n            break;\n\n        case 'X':\n            // Back up one byte\n            if (quantifier === '*') {\n                throw new Error('Warning: pack(): Type X: \\'*\\' ignored');\n            }\n            for (i = 0; i < quantifier; i++) {\n                if (result.length === 0) {\n                    throw new Error('Warning: pack(): Type X:' + ' outside of string');\n                } else {\n                    result = result.substring(0, result.length - 1);\n                }\n            }\n            break;\n\n        case '@':\n            // NUL-fill to absolute position\n            if (quantifier === '*') {\n                throw new Error('Warning: pack(): Type X: \\'*\\' ignored');\n            }\n            if (quantifier > result.length) {\n                extraNullCount = quantifier - result.length;\n                for (i = 0; i < extraNullCount; i++) {\n                    result += String.fromCharCode(0);\n                }\n            }\n            if (quantifier < result.length) {\n                result = result.substring(0, quantifier);\n            }\n            break;\n\n        default:\n            throw new Error('Warning:  pack() Type ' + instruction + ': unknown format code');\n        }\n    }\n    if (argumentPointer < arguments.length) {\n        throw new Error('Warning: pack(): ' + (arguments.length - argumentPointer) + ' arguments unused');\n    }\n\n    return result;\n}\n\n\n/*const dictionary = [\n    undefined, undefined, undefined, undefined, undefined, // 00-04\n                        //\"account\", // 5\n                        \"1\", \"1.0\",\n                        \"ack\", // 6\n                        \"action\", // 7\n                        \"active\", // 8\n                        \"add\", // 9\n                        \"after\", // 10\n                        \"ib\", // 11\n                        \"all\", // 12\n                        \"allow\", // 13\n                        \"apple\", // 14\n                        \"audio\", // 15\n                        \"auth\", // 16\n                        \"author\", // 17\n                        \"available\", // 18\n                        \"bad-protocol\", // 19\n                        \"bad-request\", // 20\n                        \"before\",\n                        \"Bell.caf\",\n                        \"body\",\n                        \"Boing.caf\",\n                        \"cancel\", // 25\n                        \"category\",\n                        \"challenge\",\n                        \"chat\",\n                        \"clean\",\n                        \"code\", // 30\n                        \"composing\",\n                        \"config\",\n                        \"conflict\",\n                        \"contacts\",\n                        \"count\", // 35\n                        \"create\",\n                        \"creation\",\n                        \"default\",\n                        \"delay\",\n                        \"delete\", // 40\n                        \"delivered\",\n                        \"deny\",\n                        \"digest\",\n                        \"DIGEST-MD5-1\",\n                        \"DIGEST-MD5-2\", // 45\n                        \"dirty\",\n                        \"elapsed\",\n                        \"broadcast\",\n                        \"enable\",\n                        \"encoding\", // 50\n                        \"duplicate\",\n                        \"error\",\n                        \"event\",\n                        \"expiration\",\n                        \"expired\", // 55\n                        \"fail\",\n                        \"failure\",\n                        \"false\",\n                        \"favorites\",\n                        \"feature\", // 60\n                        \"features\",\n                        \"field\",\n                        \"first\",\n                        \"free\",\n                        \"from\", // 65\n                        \"g.us\",\n                        \"get\",\n                        \"Glass.caf\",\n                        \"google\",\n                        \"group\", // 70\n                        \"groups\",\n                        \"g_notify\",\n                        \"g_sound\",\n                        \"Harp.caf\",\n                        \"http://etherx.jabber.org/streams\", // 75\n                        \"http://jabber.org/protocol/chatstates\",\n                        \"id\",\n                        \"image\",\n                        \"img\",\n                        \"inactive\", // 80\n                        \"index\",\n                        \"internal-server-error\",\n                        \"invalid-mechanism\",\n                        \"ip\",\n                        \"iq\", // 85\n                        \"item\",\n                        \"item-not-found\",\n                        \"user-not-found\",\n                        \"jabber:iq:last\",\n                        \"jabber:iq:privacy\", // 90\n                        \"jabber:x:delay\",\n                        \"jabber:x:event\",\n                        \"jid\",\n                        \"jid-malformed\",\n                        \"kind\", // 95\n                        \"last\",\n                        \"latitude\",\n                        \"lc\",\n                        \"leave\",\n                        \"leave-all\", // 100\n                        \"lg\",\n                        \"list\",\n                        \"location\",\n                        \"longitude\",\n                        \"max\", // 105\n                        \"max_groups\",\n                        \"max_participants\",\n                        \"max_subject\",\n                        \"mechanism\",\n                        \"media\", // 110\n                        \"message\",\n                        \"message_acks\",\n                        \"method\",\n                        \"microsoft\",\n                        \"missing\", // 115\n                        \"modify\",\n                        \"mute\",\n                        \"name\",\n                        \"nokia\",\n                        \"none\", // 120\n                        \"not-acceptable\",\n                        \"not-allowed\",\n                        \"not-authorized\",\n                        \"notification\",\n                        \"notify\", // 125\n                        \"off\",\n                        \"offline\",\n                        \"order\",\n                        \"owner\",\n                        \"owning\", // 130\n                        \"paid\",\n                        \"participant\",\n                        \"participants\",\n                        \"participating\",\n                        \"password\", // 135\n                        \"paused\",\n                        \"picture\",\n                        \"pin\",\n                        \"ping\",\n                        \"platform\", // 140\n                        \"pop_mean_time\",\n                        \"pop_plus_minus\",\n                        \"port\",\n                        \"presence\",\n                        \"preview\", // 145\n                        \"probe\",\n                        \"proceed\",\n                        \"prop\",\n                        \"props\",\n                        \"p_o\", // 150\n                        \"p_t\",\n                        \"query\",\n                        \"raw\",\n                        \"reason\",\n                        \"receipt\", // 155\n                        \"receipt_acks\",\n                        \"received\",\n                        \"registration\",\n                        \"relay\",\n                        \"remote-server-timeout\", // 160\n                        \"remove\",\n                        \"Replaced by new connection\",\n                        \"request\",\n                        \"required\",\n                        \"resource\", // 165\n                        \"resource-constraint\",\n                        \"response\",\n                        \"result\",\n                        \"retry\",\n                        \"rim\", // 170\n                        \"s.whatsapp.net\",\n                        \"s.us\",\n                        \"seconds\",\n                        \"server\",\n                        \"server-error\", // 175\n                        \"service-unavailable\",\n                        \"set\",\n                        \"show\",\n                        \"sid\",\n                        \"silent\", // 180\n                        \"sound\",\n                        \"stamp\",\n                        \"unsubscribe\",\n                        \"stat\",\n                        \"status\", // 185\n                        \"stream:error\",\n                        \"stream:features\",\n                        \"subject\",\n                        \"subscribe\",\n                        \"success\", // 190\n                        \"sync\",\n                        \"system-shutdown\",\n                        \"s_o\",\n                        \"s_t\",\n                        \"t\", // 195\n                        \"text\",\n                        \"timeout\",\n                        \"TimePassing.caf\",\n                        \"timestamp\",\n                        \"to\", // 200\n                        \"Tri-tone.caf\",\n                        \"true\",\n                        \"type\",\n                        \"unavailable\",\n                        \"uri\", // 205\n                        \"url\",\n                        \"urn:ietf:params:xml:ns:xmpp-sasl\",\n                        \"urn:ietf:params:xml:ns:xmpp-stanzas\",\n                        \"urn:ietf:params:xml:ns:xmpp-streams\",\n                        \"urn:xmpp:delay\", // 210\n                        \"urn:xmpp:ping\",\n                        \"urn:xmpp:receipts\",\n                        \"urn:xmpp:whatsapp\",\n                        \"urn:xmpp:whatsapp:account\",\n                        \"urn:xmpp:whatsapp:dirty\", // 215\n                        \"urn:xmpp:whatsapp:mms\",\n                        \"urn:xmpp:whatsapp:push\",\n                        \"user\",\n                        \"username\",\n                        \"value\", // 220\n                        \"vcard\",\n                        \"version\",\n                        \"video\",\n                        \"w\",\n                        \"w:g\", // 225\n                        \"w:p\",\n                        \"w:p:r\",\n                        \"w:profile:picture\",\n                        \"wait\",\n                        \"x\", // 230\n                        \"xml-not-well-formed\",\n                        \"xmlns\",\n                        \"xmlns:stream\",\n                        \"Xylophone.caf\",\n                        \"1\", // 235\n                        \"WAUTH-1\"    \n];*/\n\n\nconst dictionary =\n\t[\n        undefined, \"stream:stream\", \"/stream:stream\", undefined, undefined,\n        \"1\", \"1.0\", \"ack\", \"action\", \"active\", \"add\", \"all\", \"allow\", \"apple\", \"audio\", \"auth\", \"author\", \"available\",\n        \"bad-request\", \"base64\", \"Bell.caf\", \"bind\", \"body\", \"Boing.caf\",\n        \"cancel\", \"category\", \"challenge\", \"chat\", \"clean\", \"code\", \"composing\", \"config\", \"conflict\", \"contacts\", \"create\", \"creation\",\n        \"default\", \"delay\", \"delete\", \"delivered\", \"deny\", \"DIGEST-MD5\", \"DIGEST-MD5-1\", \"dirty\",\n        \"en\", \"enable\", \"encoding\", \"error\", \"expiration\", \"expired\",\n        \"failure\", \"false\", \"favorites\", \"feature\", \"field\", \"free\", \"from\",\n        \"g.us\", \"get\", \"Glass.caf\", \"google\", \"group\", \"groups\", \"g_sound\",\n        \"Harp.caf\", \"http://etherx.jabber.org/streams\", \"http://jabber.org/protocol/chatstates\",\n        \"id\", \"image\", \"img\", \"inactive\", \"internal-server-error\", \"iq\", \"item\", \"item-not-found\",\n        \"jabber:client\", \"jabber:iq:last\", \"jabber:iq:privacy\", \"jabber:x:delay\", \"jabber:x:event\", \"jid\", \"jid-malformed\",\n        \"kind\",\n        \"leave\", \"leave-all\", \"list\", \"location\",\n        \"max_groups\", \"max_participants\", \"max_subject\", \"mechanism\", \"mechanisms\", \"media\", \"message\", \"message_acks\", \"missing\", \"modify\",\n        \"name\", \"not-acceptable\", \"not-allowed\", \"not-authorized\", \"notify\",\n        \"Offline Storage\", \"order\", \"owner\", \"owning\",\n        \"paid\", \"participant\", \"participants\", \"participating\", \"particpants\", \"paused\", \"picture\", \"ping\", \"PLAIN\", \"platform\", \"presence\",\n        \"preview\", \"probe\", \"prop\", \"props\", \"p_o\", \"p_t\",\n        \"query\",\n        \"raw\", \"receipt\", \"receipt_acks\", \"received\", \"relay\", \"remove\", \"Replaced by new connection\", \"request\", \"resource\", \"resource-constraint\",\n        \"response\", \"result\", \"retry\", \"rim\",\n        \"s.whatsapp.net\", \"seconds\", \"server\", \"session\", \"set\", \"show\", \"sid\", \"sound\", \"stamp\", \"starttls\", \"status\", \"stream:error\",\n        \"stream:features\", \"subject\", \"subscribe\", \"success\", \"system-shutdown\", \"s_o\", \"s_t\",\n        \"t\", \"TimePassing.caf\", \"timestamp\", \"to\", \"Tri-tone.caf\", \"type\",\n        \"unavailable\", \"uri\", \"url\", \"urn:ietf:params:xml:ns:xmpp-bind\", \"urn:ietf:params:xml:ns:xmpp-sasl\", \"urn:ietf:params:xml:ns:xmpp-session\",\n        \"urn:ietf:params:xml:ns:xmpp-stanzas\", \"urn:ietf:params:xml:ns:xmpp-streams\", \"urn:xmpp:delay\", \"urn:xmpp:ping\", \"urn:xmpp:receipts\",\n        \"urn:xmpp:whatsapp\", \"urn:xmpp:whatsapp:dirty\", \"urn:xmpp:whatsapp:mms\", \"urn:xmpp:whatsapp:push\",\n        \"value\", \"vcard\", \"version\", \"video\",\n        \"w\", \"w:g\", \"w:p:r\", \"wait\",\n        \"x\", \"xml-not-well-formed\", \"xml:lang\", \"xmlns\", \"xmlns:stream\", \"Xylophone.caf\",\n        \"account\",\"digest\",\"g_notify\",\"method\",\"password\",\"registration\",\"stat\",\"text\",\"user\",\"username\",\"event\",\"latitude\",\"longitude\",\n        \"true\", \"after\", \"before\", \"broadcast\", \"count\", \"features\", \"first\", \"index\", \"invalid-mechanism\", undefined, // 205-214\n        \"max\", \"offline\", \"proceed\", \"required\", \"sync\", \"elapsed\", \"ip\", \"microsoft\", \"mute\", \"nokia\", \"off\", \"pin\", // 215-226\n        \"pop_mean_time\", \"pop_plus_minus\", \"port\", \"reason\", \"server-error\", \"silent\", \"timeout\", \"lc\", \"lg\", \"bad-protocol\", // 227-236\n        \"none\", \"remote-server-timeout\", \"service-unavailable\", //\"w:p\"\n        undefined, \"w:profile:picture\", \"notification\" // 237-242\n    ];\n","/home/travis/build/npmtest/node-npmtest-node-wa/node_modules/node-wa/libs/base64.js":"var base64 = {\n    encode: function(unencoded) {\n        return new Buffer(unencoded || '').toString('base64');\n    },\n    decode: function(encoded) {\n        return new Buffer(encoded || '', 'base64').toString('utf8');\n    }\n};\n\nexports.base64 = base64;\n","/home/travis/build/npmtest/node-npmtest-node-wa/node_modules/node-wa/libs/uuid.js":"//     node-uuid/uuid.js\n//\n//     Copyright (c) 2010 Robert Kieffer\n//     Dual licensed under the MIT and GPL licenses.\n//     Documentation and details at https://github.com/broofa/node-uuid\n(function() {\n  var _global = this;\n\n  // Unique ID creation requires a high quality random # generator, but\n  // Math.random() does not guarantee \"cryptographic quality\".  So we feature\n  // detect for more robust APIs, normalizing each method to return 128-bits\n  // (16 bytes) of random data.\n  var mathRNG, nodeRNG, whatwgRNG;\n\n  // Math.random()-based RNG.  All platforms, very fast, unknown quality\n  var _rndBytes = new Array(16);\n  mathRNG = function() {\n    var r, b = _rndBytes, i = 0;\n\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n      b[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return b;\n  }\n\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // WebKit only (currently), moderately fast, high quality\n  if (_global.crypto && crypto.getRandomValues) {\n    var _rnds = new Uint32Array(4);\n    whatwgRNG = function() {\n      crypto.getRandomValues(_rnds);\n\n      for (var c = 0 ; c < 16; c++) {\n        _rndBytes[c] = _rnds[c >> 2] >>> ((c & 0x03) * 8) & 0xff;\n      }\n      return _rndBytes;\n    }\n  }\n\n  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html\n  // Node.js only, moderately fast, high quality\n  try {\n    var _rb = require('crypto').randomBytes;\n    nodeRNG = _rb && function() {\n      return _rb(16);\n    };\n  } catch (e) {}\n\n  // Select RNG with best quality\n  var _rng = nodeRNG || whatwgRNG || mathRNG;\n\n  // Buffer class to use\n  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;\n\n  // Maps for number <-> hex string conversion\n  var _byteToHex = [];\n  var _hexToByte = {};\n  for (var i = 0; i < 256; i++) {\n    _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n    _hexToByte[_byteToHex[i]] = i;\n  }\n\n  // **`parse()` - Parse a UUID into it's component bytes**\n  function parse(s, buf, offset) {\n    var i = (buf && offset) || 0, ii = 0;\n\n    buf = buf || [];\n    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n      if (ii < 16) { // Don't overflow!\n        buf[i + ii++] = _hexToByte[oct];\n      }\n    });\n\n    // Zero out remaining bytes if string was short\n    while (ii < 16) {\n      buf[i + ii++] = 0;\n    }\n\n    return buf;\n  }\n\n  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**\n  function unparse(buf, offset) {\n    var i = offset || 0, bth = _byteToHex;\n    return  bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] + '-' +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]] +\n            bth[buf[i++]] + bth[buf[i++]];\n  }\n\n  // **`v1()` - Generate time-based UUID**\n  //\n  // Inspired by https://github.com/LiosK/UUID.js\n  // and http://docs.python.org/library/uuid.html\n\n  // random #'s we need to init node and clockseq\n  var _seedBytes = _rng();\n\n  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n  var _nodeId = [\n    _seedBytes[0] | 0x01,\n    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n  ];\n\n  // Per 4.2.2, randomize (14 bit) clockseq\n  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n  // Previous uuid creation time\n  var _lastMSecs = 0, _lastNSecs = 0;\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v1(options, buf, offset) {\n    var i = buf && offset || 0;\n    var b = buf || [];\n\n    options = options || {};\n\n    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;\n\n    // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n    var msecs = options.msecs != null ? options.msecs : new Date().getTime();\n\n    // Per 4.2.1.2, use count of uuid's generated during the current clock\n    // cycle to simulate higher resolution clock\n    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;\n\n    // Time since last uuid creation (in msecs)\n    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n    // Per 4.2.1.2, Bump clockseq on clock regression\n    if (dt < 0 && options.clockseq == null) {\n      clockseq = clockseq + 1 & 0x3fff;\n    }\n\n    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n    // time interval\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {\n      nsecs = 0;\n    }\n\n    // Per 4.2.1.2 Throw error if too many uuids are requested\n    if (nsecs >= 10000) {\n      throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n    }\n\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n\n    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n    msecs += 12219292800000;\n\n    // `time_low`\n    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n    b[i++] = tl >>> 24 & 0xff;\n    b[i++] = tl >>> 16 & 0xff;\n    b[i++] = tl >>> 8 & 0xff;\n    b[i++] = tl & 0xff;\n\n    // `time_mid`\n    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n    b[i++] = tmh >>> 8 & 0xff;\n    b[i++] = tmh & 0xff;\n\n    // `time_high_and_version`\n    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n    b[i++] = tmh >>> 16 & 0xff;\n\n    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n    b[i++] = clockseq >>> 8 | 0x80;\n\n    // `clock_seq_low`\n    b[i++] = clockseq & 0xff;\n\n    // `node`\n    var node = options.node || _nodeId;\n    for (var n = 0; n < 6; n++) {\n      b[i + n] = node[n];\n    }\n\n    return buf ? buf : unparse(b);\n  }\n\n  // **`v4()` - Generate random UUID**\n\n  // See https://github.com/broofa/node-uuid for API details\n  function v4(options, buf, offset) {\n    // Deprecated - 'format' argument, as supported in v1.2\n    var i = buf && offset || 0;\n\n    if (typeof(options) == 'string') {\n      buf = options == 'binary' ? new BufferClass(16) : null;\n      options = null;\n    }\n    options = options || {};\n\n    var rnds = options.random || (options.rng || _rng)();\n\n    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n    // Copy bytes to buffer, if provided\n    if (buf) {\n      for (var ii = 0; ii < 16; ii++) {\n        buf[i + ii] = rnds[ii];\n      }\n    }\n\n    return buf || unparse(rnds);\n  }\n\n  // Export public API\n  var uuid = v4;\n  uuid.v1 = v1;\n  uuid.v4 = v4;\n  uuid.parse = parse;\n  uuid.unparse = unparse;\n  uuid.BufferClass = BufferClass;\n\n  // Export RNG options\n  uuid.mathRNG = mathRNG;\n  uuid.nodeRNG = nodeRNG;\n  uuid.whatwgRNG = whatwgRNG;\n\n  if (typeof(module) != 'undefined') {\n    // Play nice with node.js\n    module.exports = uuid;\n  } else {\n    // Play nice with browsers\n    var _previousRoot = _global.uuid;\n\n    // **`noConflict()` - (browser only) to reset global 'uuid' var**\n    uuid.noConflict = function() {\n      _global.uuid = _previousRoot;\n      return uuid;\n    }\n    _global.uuid = uuid;\n  }\n}());","/home/travis/build/npmtest/node-npmtest-node-wa/node_modules/node-wa/libs/whatsapp.js":"var fs = require('fs');\n\nvar log = {\n    log: function(str) {\n        var d = new Date();\n        var dt = (d.getMonth() + 1) + \"/\" + d.getDate() + \"/\" + d.getFullYear() + \" \" + d.getHours() + \":\" + d.getMinutes();\n        fs.open('/tmp/main.log', 'a', function(err, file) {\n            fs.write(file, dt + \":\" + str);\n        });\n    },\n    stream: function(str) {\n        var d = new Date();\n        var dt = (d.getMonth() + 1) + \"/\" + d.getDate() + \"/\" + d.getFullYear() + \" \" + d.getHours() + \":\" + d.getMinutes();\n        fs.open('/tmp/stream.log', 'a', function(err, file) {\n            if(!err) {\n                fs.write(file, dt + \":\" + str);\n            } else {\n                console.log(err);\n            }\n        });\n    }\n};\n\nvar EventEmitter = require('events').EventEmitter;\n\nif(process.version == \"v0.2.3\") {\n    util = {};\n    util.inherits = require('sys').inherits;\n} else {\n    util = require('util');\n}\n\n/* ProtocolTreeNode -- just a basic representation of a XML node */\n\nvar ProtocolTreeNode = function(tag, attributes, children, data) {\n    this.tag = tag;\n    this.attributes = attributes;\n    this.children = children;\n    this.data = data;\n}\n\nProtocolTreeNode.prototype.toString = function(indent) {\n    var out = indent ? \"    \" : \"\";\n    out += \"<\" + this.tag;\n    if(this.attributes) {\n        for(var x in this.attributes) {\n            out += \" \" + x + '=\"' + this.attributes[x] + '\"';\n        }\n    }\n    out += \">\\n\";\n    if(this.data) {\n        out += (indent ? \"        \" : \"    \") + this.data + \"\\n\";\n    }\n    if(this.children) {\n        for(var c in this.children) {\n            out += this.children[c].toString({ indent: true });\n        }\n    }\n    out += (indent ? \"    \" : \"\") + \"</\" + this.tag + \">\\n\";\n    return out;\n}\n\nProtocolTreeNode.prototype.tagEquals = function(node, string) {\n    return node && node.tag && node.tag === string;\n}\n\nProtocolTreeNode.prototype.require = function(node, string) {\n    if(!this.tagEquals(node, string)) {\n        throw(\"failed require. node: \" + node + \" string: \" + string);\n    }\n}\n\nProtocolTreeNode.prototype.getChild = function(identifier) {\n    if(!this.children || this.children.length == 0) {\n        return undefined;\n    }\n    if(typeof identifier === \"number\") {\n        if(this.children.length > identifier) {\n            return this.children[identifier];\n        } else {\n            return undefined;\n        }\n    }\n    for(var c in this.children) {\n        if(identifier === this.children[c].tag) {\n            return this.children[c];\n        }\n    }\n    return undefined;\n}\n\nProtocolTreeNode.prototype.getAttributeValue = function(string) {\n    if(!this.attributes) {\n        return undefined;\n    }\n    return this.attributes[string];\n}\n\nProtocolTreeNode.prototype.getAllChildren = function(tag) {\n    var ret = [];\n    if(!this.children) {\n        return ret;\n    }\n    if(!tag) {\n        return this.children;\n    }\n    for(var c in this.children) {\n        if(tag === this.children[c].tag) {\n            ret.push(this.children[c]);\n        }\n    }\n    return ret;\n}\n\n/* BinTreeNodeReader -- give it an input stream, and it should be able to read data into something we can process */\n\nvar BinTreeNodeReader = function(inputstream, dictionary, opt) {\n    this.debug = opt ? opt.debug : false;\n    this.tokenMap = dictionary;\n    this.rawIn = inputstream;\n    this.inn = new Buffer(0);\n    this.buf = new Buffer(1024);\n    this.bufSize = 0;\n    this.readSize = 1;\n    this.innPointer = 0;\n}\n\nutil.inherits(BinTreeNodeReader, EventEmitter);\n\nBinTreeNodeReader.prototype.streamStart = function() {\n    this.rawIn.addListener('data', function dataReceived(data) {\n        this.inn = data;\n        if(!this.streamStarted) {\n            var stanzaSize = this.readInt16();\n            var tag = this.readInt8();\n            var size = this.readListSize(tag);\n            tag = this.inn[this.innPointer++];\n            if(tag != 1) {\n                throw(\"Expecting tag 1 (STREAM_START) received \" + tag + \": \" + this.getToken(tag));\n            }\n            var attribCount = (size - 2 + size % 2) / 2;\n            var attributes = this.readAttributes(attribCount);\n            this.streamStarted = true;\n        }\n        for(var x = this.innPointer; x < this.inn.length; x++) {\n            var next = this.nextTree();\n            x = this.innPointer;\n        }\n        this.innPointer = 0;\n        this.inn = new Buffer(\"\");\n    }.bind(this));\n}\n\nBinTreeNodeReader.prototype.nextTree = function() {\n    var stanzaSize = this.readInt16();\n    return this.nextTreeInternal();\n}\n\nBinTreeNodeReader.prototype.nextTreeInternal = function() {\n    var node;\n    var b = this.readInt8();\n    var size = this.readInt8();\n    \n    b = this.readInt8();\n    if(b == 2) {\n        console.log(\"** Stream closed, received tag 2\");\n        log.log(\"** Stream closed, received tag 2\");\n        log.stream(\"** Stream closed, received tag 2\");\n        return undefined;\n    }\n    var tag = this.readString(b);\n    if(size == 0 || !tag) {\n        throw(\"nextTree sees 0 list or null tag\");\n    }\n    var attribCount = (size - 2 + size % 2) / 2;\n    attribs = this.readAttributes(attribCount);\n    if(size % 2 == 1) {\n        node = new ProtocolTreeNode(tag, attribs);\n    }\n    if(!node) {\n        b = this.readInt8();\n        if(this.isListTag(b)) {\n            node = new ProtocolTreeNode(tag, attribs, this.readList(b));\n        }\n        if(!node) {\n            node = new ProtocolTreeNode(tag, attribs, undefined, this.readString(b));\n        }\n    }\n    \n    switch(node.tag) {\n        case \"challenge\":\n            this.emit('challenge', node);\n            break;\n        case \"success\":\n            this.emit('loggedin', node);\n            break;\n        case \"received\": // received is a sub of message, do not pass it on\n        case \"notify\": // received is a sub of message, do nto pass it on\n        case \"request\": // request is a sub of message, do not pass it on\n        case \"media\": // media is a sub of message, do not pass it on\n        case \"category\": // category is a sub of presence, perhaps others? who knows\n        case \"ping\": // ping is a sub of iq\n            break;\n        case \"query\": // query xmlns=jabber:iq:last is handled as part of an iq\n            if(node.getAttributeValue(\"xmlns\") != \"jabber:iq:last\") {\n                this.emit('stanza', node);\n            } else {\n                break;\n            }\n        case \"iq\":\n            this.emit('iq', node);\n            break;\n        case \"presence\":\n            this.emit('presence', node);\n            break;\n        case \"message\":\n            this.emit('message', node);\n            break;\n        case \"stream:error\":\n            this.emit('streamError', node);\n            break;\n        default:\n            this.emit('stanza', node);\n            break;\n    }\n    log.stream(\"incoming:\\n\" + node);\n    return node;\n}\n\nBinTreeNodeReader.prototype.isListTag = function(b) {\n    return b == 248 || b == 0 || b == 249;\n}\n\nBinTreeNodeReader.prototype.readList = function(token) {\n    var size = this.readListSize(token);\n    var listx = [];\n    for(var i = 0; i < size; i ++) {\n        listx.push(this.nextTreeInternal());\n    }\n    return listx;\n}\n\nBinTreeNodeReader.prototype.readInt8 = function() {\n    return this.inn[this.innPointer++];\n}\n\nBinTreeNodeReader.prototype.readInt16 = function() {\n    //return this.readInt8() + this.readInt8();\n    var a = this.readInt8();\n    var b = this.readInt8();\n    return (a << 8) + b;\n}\n\nBinTreeNodeReader.prototype.readInt24 = function() {\n    var a = this.readInt8();\n    var b = this.readInt8();\n    var c = this.readInt8();\n    //console.log(\"readInt24: \" + a + \",\" + b + \",\" + c + \"=\" + (a+b+c));\n    //console.log(\"shift: \" + ((a << 16) + (b << 8) + c));\n    //return this.readInt8() + this.readInt8() + this.readInt8();\n    return (a << 16) + (b << 8) + c;\n}\n\nBinTreeNodeReader.prototype.readListSize = function(token) {\n    var size = 0;\n    if(token == 0) {\n        size = 0;\n    } else {\n        if(token == 248) {\n            size = this.readInt8();\n        } else {\n            if(token == 249) {\n                size = this.readInt16();\n            } else {\n                throw(\"invalid list size in readListSize token \" + token);\n            }\n        }\n    }\n    return size;\n}\n\nBinTreeNodeReader.prototype.fillBuffer = function(size) {\n    this.innPointer += size;\n}\n\nBinTreeNodeReader.prototype.readAttributes = function(attribCount) {\n    var attribs = { };\n    for(var i = 0; i < attribCount; i++) {\n        var key = this.readString(this.readInt8());\n        var value = this.readString(this.readInt8());\n        attribs[key] = value;\n    }\n    return attribs;\n}\n\nBinTreeNodeReader.prototype.getToken = function(token) {\n    if(token >= 0 && token < this.tokenMap.length) {\n        var ret = this.tokenMap[token];\n    } else {\n        throw(\"invalid token/length in getToken \" + token);\n    }\n    return ret;\n}\n\nBinTreeNodeReader.prototype.readString = function(token) {\n    if(token == -1) {\n        throw(\"-1 token in readString\");\n    }\n    if(token > 0 && token < 245) {\n        return this.getToken(token);\n    }\n    if(token == 0) {\n        return undefined;\n    }\n    if(token == 252) {\n        var size8 = this.readInt8();\n        var buf8 = this.inn.slice(this.innPointer, this.innPointer + size8);\n        this.innPointer += size8;\n        return buf8.toString(\"ascii\");\n    }\n    if(token == 253) {\n        try {\n            var size24 = this.readInt24();\n            var buf24 = this.inn.slice(this.innPointer, this.innPointer + size24);\n            console.log(\"24bit read, size24=\" + size24 + \" inn.length=\" + this.inn.length + \" innPointer=\" + this.innPointer);\n            this.innPointer += size24;\n            return buf24.toString(\"ascii\");\n        } catch(err) {\n            return \"Bad Buf24 read, size24=\" + size24 + \" inn.length=\" + this.inn.length + \" innPointer=\" + this.innPointer;\n        }\n    }\n    if(token == 254) {\n        token = this.readInt8();\n        return this.getToken(245 + token);\n    }\n    if(token == 250) {\n        var user = this.readString(this.readInt8());\n        var server = this.readString(this.readInt8());\n        if(user && server) {\n            return user + \"@\" + server;\n        } else if(server) {\n            return server;\n        } else {\n            throw(\"readString couldn't reconstruct jid\");\n        }\n    }\n    throw(\"readString couldn't match token \" + token);\n}\n\n/* BinTreeNodeWriter -- this should output junk to our output stream */\n\nvar BinTreeNodeWriter = function(outputstream, dictionary, opt) {\n    this.debug = opt ? opt.debug : false;\n    this.realOut = outputstream;\n    this.tokenMap = {};\n    this.out = new Buffer(\"\");\n    for(var i = 0; i < dictionary.length; i++) {\n        if(dictionary[i]) {\n            this.tokenMap[dictionary[i]] = i;\n        }\n    }\n}\n\nBinTreeNodeWriter.prototype.streamStart = function(domain, resource) {\n    //var out = new Buffer(\"WA\\x01\\x00\", \"binary\");\n    var out = new Buffer(\"WA\\x01\\x01\", \"binary\");\n    this.realOut.write(out);\n    \n    var node = new ProtocolTreeNode(\"stream:stream\", { \"to\": domain, \"resource\": resource } );\n    this.write(node);\n}\n\nBinTreeNodeWriter.prototype.writeListStart = function(i) {\n    if(i == 0) {\n        return new Buffer(\"\\x00\");\n    } else if(i < 256) {\n        return new Buffer(\"\\xf8\" + this.writeInt8(i).toString(\"binary\"), \"binary\");\n    } else {\n        return new Buffer(\"\\xf9\" + this.writeInt16(i).toString(\"binary\"), \"binary\");\n    }\n}\n\nBinTreeNodeWriter.prototype.writeJid = function(user, server) {\n    var x = Buffer(\"\\xFA\" + (user ? this.writeString(user) : this.writeToken(0)).toString(\"binary\") + this.writeString(server).toString(\"binary\"), \"binary\");\n    return x.toString(\"binary\");\n}\n\nBinTreeNodeWriter.prototype.writeAttributes = function(attributes) {\n    var buf = new Buffer(\"\");\n    if(attributes) {\n        for(var x in attributes) {\n            //console.log(\"writing attribute \" + x + \":\" + attributes[x]);\n            var key = this.writeString(x);\n            var val = this.writeString(attributes[x]);\n            buf = new Buffer(buf.toString(\"binary\") + key.toString(\"binary\") + val.toString(\"binary\"), \"binary\");\n        }\n    }\n    return buf;\n}\n\nBinTreeNodeWriter.prototype.writeString = function(tag) {\n    //console.log(\"writeString: \" + tag);\n    var key = this.tokenMap[tag];\n    if(key) {\n        return this.writeToken(key);\n    } else {\n        var atIndex = tag ? tag.indexOf('@') : -1;\n        if(atIndex < 1) {\n            return this.writeBytes(tag);\n        } else {\n            var server = tag.substring(atIndex+1, tag.length);\n            var user = tag.substring(0, atIndex);\n            return this.writeJid(user, server);\n        }\n    }\n}\n\nBinTreeNodeWriter.prototype.writeToken = function(intValue) {\n    if(intValue < 245) {\n        return this.writeInt8(intValue);\n    } else if(intValue <= 500) {\n        return new Buffer(\"\\xFE\" + this.writeInt8(intValue - 245).toString(\"binary\"), \"binary\");\n    }\n}\n\nBinTreeNodeWriter.prototype.writeBytes = function(bytes) {\n    var length = bytes ? bytes.length : 0;\n    var buf;\n    if(length >= 256) {\n        buf = new Buffer(\"\\xfd\" + this.writeInt24(length).toString(\"binary\"), \"binary\"); // 253\n    } else {\n        buf = new Buffer(\"\\xfc\" + this.writeInt8(length).toString(\"binary\"), \"binary\"); // 252\n    }\n    buf = new Buffer(buf.toString(\"binary\") + bytes, \"binary\");\n    return buf;\n}\n\nBinTreeNodeWriter.prototype.write = function(node, needsFlush) {\n    if(!node) {\n        this.writeInt8(0);\n    } else {\n        this.writeInternal(node);\n    }\n    this.flushBuffer();\n}\n\nBinTreeNodeWriter.prototype.writeInternal = function(node) {\n    if(node.tag == undefined) {\n        console.log(\"writeInternal: *** WTF, node.tag is undefined, node=\" + JSON.stringify(node));\n    }\n    log.stream(\"outgoing:\\n\" + node);\n    var attlength = 0;\n    if(node.attributes) {\n        for(var x in node.attributes) {\n            if(node.attributes.hasOwnProperty(x))\n                attlength++;\n        }\n    }\n    var x = 1 + (node.attributes ? attlength * 2 : 0) + (node.children ? 1 : 0) + (node.data ? 1 : 0);\n    \n    var liststart = this.writeListStart(x);\n    \n    var tagstring = this.writeString(node.tag);\n    \n    var attrib = this.writeAttributes(node.attributes);\n     \n    this.out = new Buffer(this.out.toString(\"binary\") + liststart.toString(\"binary\") + tagstring.toString(\"binary\") + attrib.toString(\"binary\"), \"binary\");\n    if(node.data) {\n        this.out = new Buffer(this.out.toString(\"binary\") + this.writeBytes(node.data).toString(\"binary\"), \"binary\");\n    }\n    if(node.children) {\n        this.out = new Buffer(this.out.toString(\"binary\") + this.writeListStart(node.children.length).toString(\"binary\"), \"binary\");\n        for(var c in node.children) {\n            //console.log(\"writing internal child \" + JSON.stringify(node.children[c]));\n            this.writeInternal(node.children[c]);\n        }\n    }\n}\n\nBinTreeNodeWriter.prototype.flushBuffer = function() {\n    var size = this.out.length;\n    var x = this.writeInt16(size);\n    var buf = new Buffer(x.toString(\"binary\") + this.out.toString(\"binary\"), \"binary\");\n    if(this.debug) {\n        var out = \"\";\n        for(var i = 0; i < buf.length; i++) {\n            out += buf[i] + \" \";\n        }\n        console.log(\"writing buffer of size \" + size);\n        console.log(buf.toString(\"ascii\"));\n    }\n    this.realOut.write(buf, \"binary\");\n    this.out = new Buffer(\"\");\n}\n\nBinTreeNodeWriter.prototype.writeInt8 = function(v) {\n    return new Buffer(\"\" + String.fromCharCode(v), \"binary\");\n}\n\nBinTreeNodeWriter.prototype.writeInt16 = function(v) {\n    return new Buffer(this.writeInt8( (v >> 8) & 0xFF).toString(\"binary\") + this.writeInt8(v & 0xFF).toString(\"binary\"), \"binary\");\n}\n\nBinTreeNodeWriter.prototype.writeInt24 = function(v) {\n    return new Buffer(this.writeInt8( (v >> 16) & 0xFF).toString(\"binary\") + this.writeInt8( (v >> 8) & 0xFF).toString(\"binary\") + this.writeInt8(v & 0xFF).toString(\"binary\"), \"binary\");\n}\n\nexports.ProtocolTreeNode = ProtocolTreeNode;\nexports.BinTreeNodeReader = BinTreeNodeReader;\nexports.BinTreeNodeWriter = BinTreeNodeWriter;\nexports.log = log;"}